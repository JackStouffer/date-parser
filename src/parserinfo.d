/**
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

module dateparser.parserinfo;

import std.traits;
import std.range;
import dateparser.parseresult;

package:

// dfmt off
// m from a.m/p.m, t from ISO T separator, order doesn't
// matter here, just a presence check
enum jumpDefault = [
    "and":9, "'":6,
    "at":7, "/":5,
    "st":14,
    ";":3, " ":0,
    "of":13, "nd":15,
    "rd":16, ".":1,
    "th":17, "on":8,
    "m":11, ",":2,
    "ad":10, "-":4, "t":12
];
enum weekdaysDefault = [
    "mon":0, "monday":0,
    "tue":1, "tuesday":1,
    "wed":2, "wednesday":2,
    "thu":3, "thursday":3,
    "fri":4, "friday":4,
    "sat":5, "saturday":5,
    "sun":6, "sunday":6,
];
enum monthsDefault = [
    "jan":0, "january":0,
    "feb":1, "february":1,
    "mar":2, "march":2,
    "apr":3, "april":3,
    "may":4,
    "jun":5, "june":5,
    "jul":6, "july":6,
    "aug":7, "august":7,
    "sep":8, "sept":8, "september":8,
    "oct":9, "october":9,
    "nov":10, "november":10,
    "dec":11, "december":11
];
enum hmsDefault = [
    "h":0, "hour":0, "hours":0,
    "m":1, "minute":1, "minutes":1,
    "s":2, "second":2, "seconds":2
];
enum ampmDefault = [
    "am":0, "a":0,
    "pm":1, "p":1
];
enum utcDefault = [
    "UTC":0, "GMT":0, "Z":0
];
enum pertainDefault = [
    "of":0
];
// dfmt on

/**
 * If the century isn't specified, e.g. `"'07"`, then assume that the year
 * is in the current century and return it as such. Otherwise do nothing
 *
 * Params:
 *     convertYear = year to be converted
 *     centurySpecified = is the century given in the year
 *
 * Returns:
 *     the converted year
 */
int convertYear(int convertYear, bool centurySpecified = false) @safe
{
    import std.math : abs;
    import std.datetime : Clock;

    immutable year = Clock.currTime.year;
    immutable century = (year / 100) * 100;

    if (convertYear < 100 && !centurySpecified)
    {
        convertYear += century;
        if (abs(convertYear - year) >= 50)
        {
            if (convertYear < year)
                convertYear += 100;
            else
                convertYear -= 100;
        }
    }

    return convertYear;
}

public:

/**
Class which handles what inputs are accepted. Subclass this to customize
the language and acceptable values for each parameter.

Params:
    dayFirst = Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the day (`true`) or month (`false`). If
        `yearFirst` is set to `true`, this distinguishes between YDM
        and YMD. Default is `false`.
    yearFirst = Whether to interpret the first value in an ambiguous 3-integer date
        (e.g. 01/05/09) as the year. If `true`, the first number is taken
        to be the year, otherwise the last number is taken to be the year.
        Default is `false`.
*/
class ParserInfo
{
private:
    bool dayFirst;
    bool yearFirst;

package:
    /**
     * Takes and Result and converts it year and checks if the timezone is UTC
     */
    final void validate(ref ParseResult res) @safe const
    {
        //move to info
        if (!res.year.isNull)
            res.year = convertYear(res.year, res.centurySpecified);

        if ((!res.tzoffset.isNull && res.tzoffset == 0)
                && (res.tzname.length == 0 || res.tzname == "Z"))
        {
            res.tzname = "UTC";
            res.tzoffset = 0;
        }
        else if (!res.tzoffset.isNull && res.tzoffset != 0 && res.tzname.length > 0
                 && this.utczone(res.tzname))
            res.tzoffset = 0;
    }

public:
    /**
     * AAs used for matching strings to calendar numbers, e.g. Jan is 1.
     *
     * `jumpAA`, `utczoneAA`, and `pertainAA` are only used to check the
     * presence of a key; the value of the key doesn't matter.
     */
    int[string] jumpAA;
    ///ditto
    int[string] weekdaysAA;
    ///ditto
    int[string] monthsAA;
    ///ditto
    int[string] hmsAA;
    ///ditto
    int[string] ampmAA;
    ///ditto
    int[string] utczoneAA;
    ///ditto
    int[string] pertainAA;

    /**
     * Take a range of character ranges or a range of ranges of character
     * ranges and converts it to an associative array that the internal
     * parser info methods can use.
     *
     * Use this method in order to override the default parser info field
     * values. See the example on the $(REF parse).
     *
     * Params:
     *     list = a range of character ranges
     *
     * Returns:
     *     An associative array of `int`s accessed by strings
     */
    static int[string] convert(Range)(Range list) if (isInputRange!Range
            && isSomeChar!(ElementEncodingType!(ElementEncodingType!(Range)))
            || isSomeChar!(
            ElementEncodingType!(ElementEncodingType!(ElementEncodingType!(Range)))))
    {
        import std.array : array;
        import std.conv : to;
        import std.uni : asLowerCase;

        int[string] dictionary;

        foreach (int i, value; list)
        {
            // tuple of strings or multidimensional string array
            static if (isInputRange!(ElementType!(ElementType!(Range))))
                foreach (item; value)
                    dictionary[item.asLowerCase.array.to!string] = i;
            else
                dictionary[value.asLowerCase.array.to!string] = i;
        }

        return dictionary;
    }

    /// Ctor
    this(bool dayFirst = false, bool yearFirst = false) @safe
    {
        dayFirst = dayFirst;
        yearFirst = yearFirst;

        jumpAA = jumpDefault;
        weekdaysAA = weekdaysDefault;
        monthsAA = monthsDefault;
        hmsAA = hmsDefault;
        ampmAA = ampmDefault;
        utczoneAA = utcDefault;
        pertainAA = pertainDefault;
    }

    /// Tests for presence of `name` in each of the AAs
    final bool jump(S)(const S name) const if (isSomeString!S)
    {
        import std.uni : toLower;
        return name.toLower() in jumpAA ? true : false;
    }

    /// ditto
    final int weekday(S)(const S name) const if (isSomeString!S)
    {
        import std.uni : toLower;

        if (name.toLower() in weekdaysAA)
            return weekdaysAA[name.toLower()];
        else
            return -1;
    }

    /// ditto
    final int month(S)(const S name) const if (isSomeString!S)
    {
        import std.uni : toLower;

        if (name.toLower() in monthsAA)
            return monthsAA[name.toLower()] + 1;
        else
            return -1;
    }

    /// ditto
    final int hms(S)(const S name) const if (isSomeString!S)
    {
        import std.uni : toLower;

        if (name.toLower() in hmsAA)
            return hmsAA[name.toLower()];
        else
            return -1;
    }

    /// ditto
    final int ampm(S)(const S name) const if (isSomeString!S)
    {
        import std.uni : toLower;

        if (name.toLower() in ampmAA)
            return ampmAA[name.toLower()];
        else
            return -1;
    }

    /// ditto
    final bool pertain(S)(const S name) const if (isSomeString!S)
    {
        import std.uni : toLower;

        return name.toLower() in pertainAA ? true : false;
    }

    /// ditto
    final bool utczone(S)(const S name) const if (isSomeString!S)
    {
        import std.uni : toLower;

        return name.toLower() in utczoneAA ? true : false;
    }
}